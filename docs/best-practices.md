# Best practices

## 1 - Don't place business logic in commands

Commands are the views in CLIs, the surface with whom users interact. They are responsible for parsing and validating arguments and flags using the metadata statically defined in the command classes. Any business logic associated with a command must live in a **command service** (regardless of the size or complexity of the logic). This allows writing unit tests for commands that otherwise would have been test that test the integration between the command's logic and oclif's primitives:

```
packages/
  app/
    src/
      commands/
        dev.ts
      services/
        commands/
          dev.ts
```

## 2- Fixed dependencies

The widespread practice in the Javascript community regarding dependencies is having many tiny NPM packages over few yet more complete ones.
The consequence of that is very nested dependency graphs that often lead to incompabilities between nodes and with the system.
Developers resort to deleting `node_modules` with the aim that their dependency manager will resolve the incompatibilities.
If we had soft dependency requirements and allowed `peerDependencies` we'd make projects generated by the ClI more prone to these issues.
That's not what we want. Therefore, the CLI should have strict dependency requirements and avoid the usage of peer dependencies.
Moreover, the addition of `@shopify/cli` as a dependency will pull everything that's necessary for building for Shopify, and that includes runtime dependencies and tools.
