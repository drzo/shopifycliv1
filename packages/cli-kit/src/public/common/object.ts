import {unionArrayStrategy} from '../../private/common/array.js'
import deepMerge from 'deepmerge'
import {Dictionary, ObjectIterator, ValueKeyIteratee} from 'lodash'
import {createRequire} from 'module'

const require = createRequire(import.meta.url)

/**
 * Deep merges the two objects and returns a new object with the merge result.
 *
 * @param lhs - One of the objects to be merged.
 * @param rhs - Another object to be merged.
 * @param arrayMergeStrategy - Strategy used to merge the array typed fields. Union strategy is used by default to avoid
 * duplicated elements.
 * @returns A Javascrip tobject with th emerged objects.
 */
export function deepMergeObjects<T1, T2>(
  lhs: Partial<T1>,
  rhs: Partial<T2>,
  arrayMergeStrategy: (destinationArray: unknown[], sourceArray: unknown[]) => unknown[] = unionArrayStrategy,
): T1 & T2 {
  return deepMerge(lhs, rhs, {arrayMerge: arrayMergeStrategy})
}

/**
 * Creates an object composed of the `object` properties `predicate` returns
 * truthy for. The predicate is invoked with two arguments: (value, key).
 *
 * @param object - The source object.
 * @param predicate - The function invoked per property.
 * @returns Returns the new object.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
export function pickBy<T, S extends T>(
  object: Dictionary<T> | null | undefined,
  predicate?: ValueKeyIteratee<T>,
): Dictionary<S> {
  const lodashPickBy = require('lodash/pickBy.js')
  return lodashPickBy(object, predicate)
}

/**
 * Creates an object with the same keys as object and values generated by running each own
 * enumerable property of object through iteratee. The iteratee function is
 * invoked with three arguments: (value, key, object).
 *
 * @param source - The object to iterate over.
 * @param callback - The function invoked per iteration.
 * @returns Returns the new mapped object.
 */
export function mapValues<T extends object, TResult>(
  source: T | null | undefined,
  callback: ObjectIterator<T, TResult>,
): {[P in keyof T]: TResult} {
  const lodashMapValues = require('lodash/mapValues.js')
  return lodashMapValues(source, callback)
}

/**
 * Deeply compares two objects and returns true if they are equal.
 *
 * @param one - The first object to be compared.
 * @param two - The second object to be compared.
 * @returns True if the objects are equal, false otherwise.
 */
export function deepCompare(one: object, two: object): boolean {
  const lodashIsEqual = require('lodash/isEqual.js')
  return lodashIsEqual(one, two)
}

/**
 * Return the difference between two nested objects.
 *
 * @param one - The first object to be compared.
 * @param two - The second object to be compared.
 * @returns Two objects containing the fields that are different, each one with the values of one object.
 */
export function deepDifference<T1, T2>(one: T1, two: T2): [Partial<T1>, Partial<T2>] {
  const differenceWith = require('lodash/differenceWith.js')
  const fromPairs = require('lodash/fromPairs.js')
  const toPairs = require('lodash/toPairs.js')
  const changes = differenceWith(toPairs(one), toPairs(two), deepCompare)
  const changes2 = differenceWith(toPairs(two), toPairs(one), deepCompare)
  return [fromPairs(changes), fromPairs(changes2)]
}

/**
 * Flattens an object to an array of key paths with values.
 *
 * E.g. `{foo: {bar: 'baz'}} => [['foo.bar', 'baz']`.
 *
 * Results are returned in keypath order.
 *
 * @param input - Object to flatten.
 * @returns An array of key paths with values.
 */
export function flattenObjectToKeyPathsWithValues<T>(input: T): [string, unknown][] {
  // flattens an object so that all keys are in a single array
  const output: [string, unknown][] = []
  const stack: [string, T][] = [['', input]]
  while (stack.length > 0) {
    const [path, current] = stack.pop()!
    // this includes arrays - key would be 0, 1, 2, etc.
    if (typeof current === 'object' && current !== null) {
      for (const [key, value] of Object.entries(current)) {
        stack.push([`${path}.${key}`, value])
      }
    } else {
      output.push([path, current])
    }
  }
  return output
    .map<[string, unknown]>(([key, value]) => [key.substring(1, key.length), value])
    .sort(([keyA, _valueA], [keyB, _valueB]) => keyA.localeCompare(keyB))
}

/**
 * Flattens two objects and compares them, returning an array of key paths with values that are different, as well as the respective values.
 *
 * E.g. `{foo: 1}, {foo: 2} => [['foo', 1, 2]]`.
 *
 * Results are returned in keypath order. As objects are flattened, comparison respects deep equality.
 *
 * @param one - First object to compare.
 * @param two - Second object to compare.
 * @returns List of keypaths that differ, alongside the values from each object.
 */
export function flattenAndCompareObjects<TOne, TTwo>(one: TOne, two: TTwo): [string, unknown, unknown][] {
  const differenceWith = require('lodash/differenceWith.js')

  // flatten to [['foo.bar', 'value]...]
  const flattenedOne = flattenObjectToKeyPathsWithValues(one)
  const flattenedTwo = flattenObjectToKeyPathsWithValues(two)

  // grab the entries different in each flattened list, then convert back to a map
  const inOneNotTwo = differenceWith(flattenedOne, flattenedTwo, deepCompare) as [string, unknown][]
  const inOneNotTwoMap = Object.fromEntries(inOneNotTwo)

  const inTwoNotOne = differenceWith(flattenedTwo, flattenedOne, deepCompare) as [string, unknown][]
  const inTwoNotOneMap = Object.fromEntries(inTwoNotOne)

  // build the result
  const allKeys = new Set([...Object.keys(inOneNotTwoMap), ...Object.keys(inTwoNotOneMap)])
  const result: [string, unknown, unknown][] = []
  for (const key of allKeys) {
    result.push([key, inOneNotTwoMap[key], inTwoNotOneMap[key]])
  }

  // output in consistent ordering
  return result.sort(([keyA, _valueOneFromA, _valueTwoFromA], [keyB, _valueOneFromB, _valueTwoFromB]) =>
    keyA.localeCompare(keyB),
  )
}
